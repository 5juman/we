## 이더리움 어카운트(이더리움 계정)
이더리움의 상태는 어카운트들로 구성됨
각 어카운트는 20 바이트 주소를 가지고 어카운트 간 값과 정보를 직접적으로 전달해 주는 상태변환(state transition)이 있음.

이더리움 어카운트는 다음 네 개의 필드를 가짐
- 논스(nonce): 각 트랜잭션이 한 번만 처리되게 하는 카운터
- 현재 이더(ether) 잔고
- 계약 코드 (존재할 경우)
- 저장 공간 (초기설정 상에서는 기본적으로 비어 있음)

이더: 이더리움의 기본 내부 암호-연료, 트랜잭션 수수료 지불에 사용됨.

어카운트 종류:
① 외부 소유 어카운트: 프라이빗 키로 통제, 코드 없음, 트랜잭션 생성 및 서명 필요.
② 컨트랙트 어카운트: 컨트랙트 코드로 통제, 메시지를 받으면 코드 실행, 메시지 읽기/쓰기, 다른 메시지 전송, 컨트랙트 생성 가능.

컨트랙트: 자율 에이전트로 작동, 메시지나 트랜잭션 도착 시 코드 실행, 이더 잔고와 변수 추적을 위한 키/값 저장소 통제.


## 메시지와 트랜잭션(메시지 및 트랜잭션)

이더리움에서 트랜잭션: 외부 소유 어카운트가 보낼 메시지를 가지고 있는 서명된 데이터 패키지

다음을 포함한다:
- 메시지 수신처
-사인소스 확인
-목적지로 보내는 에테르의 양
-옵션 데이터 필드
-STARTGAS 값 : 허용되는 최대 연산 단계 수
- 가스가격: 각 계산단계에서 발생원이 지불하는 수수료

거래의 첫 세 가지 항목은 암호화폐의 표준 가치입니다.
데이터 필드에 초기 기능이 없으므로 가상 시스템에 액세스할 작업 코드(opcode)가 있습니다.
예: 도메인 등록 서비스 계약은 데이터 필드를 도메인 및 IP 주소로 해석하여 저장소에 저장합니다.
시동 가스 및 가스 가격은 서비스 거부 방지(안티도스) 모델에 중요합니다.
 -Infinite Loop, 낭비되는 연산을 피하기 위해 연산 단계 수 제한
 -계산단위는 가스, 1단계당 1가스 비용이며, 계산에 따라 비용이 증가합니다.
 -거래 데이터의 모든 바이트에는 5 가스 요금이 부과됩니다.
수수료 체계: 공격자가 사용하는 리소스에 비례하는 수수료 지불
 -자원 집약적인 거래는 가스 요금을 더 많이 부과합니다.


## 메시지(메시지)

계약은 다른 계약에 메시지를 전달할 수 있습니다.
해당 메시지는 이더리움 실행 환경에만 존재하는 가상 객체입니다.
메시지 구성:
- 메시지 출처(묵시적)
- 메시지 수신처
-이더의 배달
-옵션 데이터 필드
- STARTGAS 값
메시지는 계약에 의해 생성되는 것을 제외하고는 거래와 유사합니다.
CALL opcode를 만날 때 메시지 만들기
메시지는 해당 코드를 실행하는 수신자 계정에 도달합니다.
계약은 외부 실행자와 동일한 방식으로 다른 계약과 상호 작용할 수 있습니다.
트랜잭션 및 하위 실행에 할당된 총 가스 적용
예: A는 B에게 1000 가스를 보내고, B는 600 가스를 사용한 후 C에게 메시지를 보내고, C는 300 가스를 사용한 후에 돌아갑니다 -> B는 100 가스를 더 사용할 수 있습니다.


## 이더리움 상태 전환 기능(이더리움 상태 전환 기능) 


![이더리움 상태 변환 함수](https://github.com/5juman/we/assets/120390638/0177cb94-1bd2-466b-aa0b-d15cdd8ab562)

이더리움 상태 전이 함수 APPLY(S, TX) -> S’의 정의:
트랜잭션 형식과 서명 유효성, 논스 확인
트랜잭션 수수료 계산 후 발신처 잔고에서 차감, 발신처 논스 증가
GAS = STARTGAS로 초기화 후, 바이트당 gas 차감
발신처에서 수신처로 값 전송, 수신처가 컨트랙트면 코드 실행
값 전송 실패나 gas 부족 시 상태 변경 원상 복구, 수수료는 제외
남은 gas 수수료를 발신처에게 반환, 소모된 gas 수수료를 채굴자에게 지급

예시 컨트랙트 코드:
if!self.storage[call data load(0)]:
 self.storage[call data load(0)] = call data load(32)
이 코드는 이해하기 쉽게 Serpent로 작성되었으며, EVM 코드로 컴파일될 수 있다. 컨트랙트의 스토리지는 비어있다고 가정하고, 트랜잭션이 10 이더, 2000 gas, 0.001 이더 gasprice, 64 바이트의 데이터(0-31 바이트는 숫자 2, 32-63 바이트는 'CHARLIE')를 보낸다고 가정하자. 상태 변환 함수의 프로세스는 다음과 같다:

1. 트랜잭션 유효성 확인
2. 발송처가 2 이더 수수료를 지불할 수 있는지 확인 후, 발송처 계정에서 차감
3. gas를 2000으로 초기화하고, 트랜잭션 길이 170 바이트당 850 gas 차감하여 1150 gas 남음
4. 발송처 계정에서 추가로 10 이더를 차감하고 컨트랙트 계정에 추가
5. 컨트랙트 코드 실행: index 2 스토리지 값 확인 후 'CHARLIE'로 설정, 187 gas 소모 후 963 gas 남음
6. 963 gas 반환하여 0.963 이더를 송신처 계정으로 반환, 최종 상태 반환

트랜잭션 수신처에 컨트랙트가 없으면, 총 수수료는 GASPRICE와 트랜잭션 바이트 수를 곱한 값과 같음.
메시지 실행 시 gas가 부족하면 모든 상태가 원래대로 복구되나, 부모 실행은 복구되지 않음. 컨트랙트 간 호출은 안전하며, A가 G gas로 B를 호출하면 A의 실행은 최대 G gas만 잃음.
CREATE opcode는 CALL과 유사하게 작동하지만, 실행 결과로 새로 생성된 컨트랙트의 코드를 결정한다는 차이가 있음.


## 코드 실행(코드 실행)

이더리움 컨트랙트 구성하는 코드 = “이더리움 버추얼 머신 코드” or “EVM 코드” 
→ 로우-레벨, 스택 기반의 바이트코드 언어로 작성
연산(작업): 각 바이트는 특정 연산을 나타냄
프로그램 카운터(PC): 코드 실행 위치를 나타냄, 0부터 시작하여 연산을 순차적으로 실행
데이터 저장 공간: 세 가지 타입의 공간에 접근할 수 있어야 함
실행 과정은 무한 루프로 구성되어 있으며, 프로그램 카운터는 연산을 수행하고 이동하며, 코드의 끝에 도달하거나 오류, STOP, RETURN 명령을 만나면 실행이 멈춤

이더리움 버추얼 머신(EVM)은 다음과 같은 요소들로 구성된 단순한 실행 모델을 가지고 있음:
-스택(스택): 후입선출(LIFO) 방식의 컨테이너로, 값들을 밀어넣거나(push) 빼낼(pop) 수 있음
-메모리(메모리): 무한대로 확장 가능한 바이트 배열로, 임시 데이터를 저장하는 용도
- 컨트랙트의 영속적인(long-term) 저장소(storage): 키/값 저장소로, 계산이 끝나더라도 데이터가 영구적으로 유지됨

이더리움의 EVM 코드 실행 모델은 간단하면서도 강력한 구조를 가지고 있음 
실행 중에 모든 계산 상태는 (block_state, 트랜잭션, 메시지, 코드, 메모리, 스택, pc, gas) 튜플(tuple) 로 정의됨
전역상태인 block_state에는 잔고와 저장소(storage)를 포함한 모든 계정 정보 저장
코드 실행은 프로그램 카운터(PC)가 코드의 각 명령을 순차적으로 실행, 각 명령은 실행 상태를 변화시키는 자체 정의를 가지고 있음 
예시: ADD 명령은 스택에서 두 개의 값 합을 계산하여 스택에 넣고, 실행 비용(gas)을 감소시키며 프로그램 카운터를 1 증가시킴. 
이러한 실행 모델은 JIT 컴파일을 통해 최적화될 수 있으며, 기본적인 구현은 몇 백 줄의 코드로 이루어질 수 있음


## 블록체인과 채굴

![블록체인과 채굴](https://github.com/5juman/we/assets/120390638/ff75100a-31dc-4b04-a24d-516dbea92a7a)

이더리움 블록체인과 비트코인 블록체인은 비슷하지만 다릅니다.
이더리움과 비트코인의 블록체인 구조별 주요 차이점: 
-이더리움은 비트코인과 달리 거래목록과 최신 상태 사본을 보유하고 있습니다. 
-블록 번호와 난이도의 두 가지 값도 블록에 저장됩니다.

이더리움의 기본 블록 검증 알고리즘은 다음과 같습니다.
1.이전 블록이 존재하고 유효한지 확인합니다.
2. 현재 블록의 타임스탬프가 이전 블록보다 큰지, 동시에 현재 시간으로부터 15분 전에 확인
3. 블록 번호, 난이도, 트랜잭션 루트, uncle root, gas limit 등 다양한 값이 유효한지 확인합니다.
4. 블록에 포함된 작업증명이 유효한지 확인
5. S[0]을 이전 블록의 마지막 상태로 가정합니다.
6. 각 트랜잭션에 대해 S[i+1] = APPLY(S[i], TX[i])를 계산하고 총 소비 가스가 GASLIMIT를 초과하면 오류를 반환합니다.
7. 채굴자에게 지급되는 보상을 S_FINAL에 추가합니다.
8.S_FINAL의 Merkle 트리 루트가 블록 헤더의 최종 상태 루트와 일치하는지 확인하여 블록의 유효성을 판단합니다.

이더리움의 효율적인 블록체인 관리는 트리 구조로 상태를 저장하여 각 블록에 모든 상태를 저장할 필요가 없습니다.
→ Patricia 트리를 사용하여 노드를 효율적으로 수정, 삽입 또는 삭제할 수 있으며, 인접한 블록 간에 대부분의 상태가 동일하기 때문에 데이터를 효율적으로 저장합니다. 
이 방법은 비트코인에 비해 5~20배의 스토리지를 절약합니다. 
또한 블록체인의 상태 전이 기능은 블록 검증 알고리즘의 일부로 실행되며, 이는 모든 노드가 트랜잭션에 의해 동일하게 코드를 실행하도록 보장합니다.
