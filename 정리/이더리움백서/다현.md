> [발표영상](https://youtu.be/HcSJKkr7JxY)

## 이더리움 어카운트(이더리움 계정)
이더리움의 상태는 어카운트들로 구성됨
각 어카운트는 20 바이트 주소를 가지고 어카운트 간 값과 정보를 직접적으로 전달해 주는 상태변환(state transition)이 있음.

이더리움 어카운트는 다음 네 개의 필드를 가짐
- 논스(nonce): 각 트랜잭션이 한 번만 처리되게 하는 카운터
- 현재 이더(ether) 잔고
- 계약 코드 (존재할 경우)
- 저장 공간 (초기설정　상에서는 기본적으로 비어 있음)

이더: 이더리움의 기본 내부 암호-연료, 트랜잭션 수수료 지불에 사용됨.

어카운트 종류:
① 외부 소유 어카운트: 프라이빗 키로 통제, 코드 없음, 트랜잭션 생성 및 서명 필요.
② 컨트랙트 어카운트: 컨트랙트 코드로 통제, 메시지를 받으면 코드 실행, 메시지 읽기/쓰기, 다른 메시지 전송, 컨트랙트 생성 가능.

컨트랙트: 자율 에이전트로 작동, 메시지나 트랜잭션 도착 시 코드 실행, 이더 잔고와 변수 추적을 위한 키/값 저장소 통제.


## 메시지와 트랜잭션(메시지 및 트랜잭션)

이더리움에서 트랜잭션: 외부 소유 어카운트가 보낼 메시지를 가지고 있는 서명된 데이터 패키지

다음을 포함한다:
- 메시지 수신처
- 발신처 확인 서명
- 수신처로 보내는 이더 양
- 선택적 데이터 필드
- STARTGAS 값: 허용된 최대 계산 단계수
- GASPRICE 값: 매 계산 단계마다 발신처가 지불하는 수수료

트랜잭션의 처음 세 항목은 암호 화폐의 표준값
데이터 필드는 초기 기능 없음, 가상 머신이 접근할 수행 코드(opcode) 존재
예시: 도메인 등록 서비스 컨트랙트는 데이터 필드를 도메인과 IP 주소로 해석, 저장소에 저장
STARTGAS와 GASPRICE는 앤티-서비스거부(anti-DoS) 모델에 중요
 - 무한루프, 계산 낭비 방지 위해 계산 단계 수 제한
 - 계산 단위는 gas, 단계마다 1 gas 비용, 연산에 따라 비용 증가
 - 트랜잭션 데이터의 모든 바이트는 5 gas 수수료
수수료 시스템: 공격자가 소비한 리소스에 비례해 수수료 지불
 - 리소스를 많이 소비하는 트랜잭션은 더 높은 gas 수수료 부과


## 메시지(메시지)

컨트랙트는 다른 컨트랙트에게 메시지를 전달할 수 있음
메시지는 이더리움 실행 환경에서만 존재하는 가상 오브젝트
메시지 구성:
- 메시지 발신처 (암묵적)
- 메시지 수신처
- 전달되는 이더
- 선택적 데이터 필드
- STARTGAS 값
메시지는 컨트랙트에 의해 생성되는 점을 제외하면 트랜잭션과 유사
CALL opcode를 만나면 메시지를 생성
메시지는 해당 코드를 실행하는 수신자 어카운트에 도달
컨트랙트는 외부 실행자와 동일한 방식으로 다른 컨트랙트와 상호작용 가능
트랜잭션과 하위 실행에 할당된 총 gas 적용
예시: A가 B에게 1000gas, B가 600gas 사용 후 C에게 메시지 전달, C가 300gas 사용 후 반환 -> B는 100gas 더 사용 가능


## 이더리움 상태 전환 기능(이더리움 상태 전환 기능) 


![이더리움 상태 변환 함수](https://github.com/5juman/we/assets/120390638/0177cb94-1bd2-466b-aa0b-d15cdd8ab562)

이더리움 상태 전이 함수 APPLY(S, TX) -> S’의 정의:
트랜잭션 형식과 서명 유효성, 논스 확인
트랜잭션 수수료 계산 후 발신처 잔고에서 차감, 발신처 논스 증가
GAS = STARTGAS로 초기화 후, 바이트당 gas 차감
발신처에서 수신처로 값 전송, 수신처가 컨트랙트면 코드 실행
값 전송 실패나 gas 부족 시 상태 변경 원상 복구, 수수료는 제외
남은 gas 수수료를 발신처에게 반환, 소모된 gas 수수료를 채굴자에게 지급

예시 컨트랙트 코드:
if!self.storage[call data load(0)]:
 self.storage[call data load(0)] = call data load(32)
이 코드는 이해하기 쉽게 Serpent로 작성되었으며, EVM 코드로 컴파일될 수 있다. 컨트랙트의 스토리지는 비어있다고 가정하고, 트랜잭션이 10 이더, 2000 gas, 0.001 이더 gasprice, 64 바이트의 데이터(0-31 바이트는 숫자 2, 32-63 바이트는 'CHARLIE')를 보낸다고 가정하자. 상태 변환 함수의 프로세스는 다음과 같다:

1. 트랜잭션 유효성 확인
2. 발송처가 2 이더 수수료를 지불할 수 있는지 확인 후, 발송처 계정에서 차감
3. gas를 2000으로 초기화하고, 트랜잭션 길이 170 바이트당 850 gas 차감하여 1150 gas 남음
4. 발송처 계정에서 추가로 10 이더를 차감하고 컨트랙트 계정에 추가
5. 컨트랙트 코드 실행: index 2 스토리지 값 확인 후 'CHARLIE'로 설정, 187 gas 소모 후 963 gas 남음
6. 963 gas 반환하여 0.963 이더를 송신처 계정으로 반환, 최종 상태 반환

트랜잭션 수신처에 컨트랙트가 없으면, 총 수수료는 GASPRICE와 트랜잭션 바이트 수를 곱한 값과 같음.
메시지 실행 시 gas가 부족하면 모든 상태가 원래대로 복구되나, 부모 실행은 복구되지 않음. 컨트랙트 간 호출은 안전하며, A가 G gas로 B를 호출하면 A의 실행은 최대 G gas만 잃음.
CREATE opcode는 CALL과 유사하게 작동하지만, 실행 결과로 새로 생성된 컨트랙트의 코드를 결정한다는 차이가 있음.


## 코드 실행(코드 실행)

이더리움 컨트랙트 구성하는 코드 = “이더리움 버추얼 머신 코드” or “EVM 코드” 
→ 로우-레벨, 스택 기반의 바이트코드 언어로 작성
연산(작업): 각 바이트는 특정 연산을 나타냄
프로그램 카운터(PC): 코드 실행 위치를 나타냄, 0부터 시작하여 연산을 순차적으로 실행
데이터 저장 공간: 세 가지 타입의 공간에 접근할 수 있어야 함
실행 과정은 무한 루프로 구성되어 있으며, 프로그램 카운터는 연산을 수행하고 이동하며, 코드의 끝에 도달하거나 오류, STOP, RETURN 명령을 만나면 실행이 멈춤

이더리움 버추얼 머신(EVM)은 다음과 같은 요소들로 구성된 단순한 실행 모델을 가지고 있음:
-스택(스택): 후입선출(LIFO) 방식의 컨테이너로, 값들을 밀어넣거나(push) 빼낼(pop) 수 있음
-메모리(메모리): 무한대로 확장 가능한 바이트 배열로, 임시 데이터를 저장하는 용도
- 컨트랙트의 영속적인(long-term) 저장소(storage): 키/값 저장소로, 계산이 끝나더라도 데이터가 영구적으로 유지됨

이더리움의 EVM 코드 실행 모델은 간단하면서도 강력한 구조를 가지고 있음 
실행 중에 모든 계산 상태는 (block_state, 트랜잭션, 메시지, 코드, 메모리, 스택, pc, gas) 튜플(tuple) 로 정의됨
전역상태인 block_state에는 잔고와 저장소(storage)를 포함한 모든 계정 정보 저장
코드 실행은 프로그램 카운터(PC)가 코드의 각 명령을 순차적으로 실행, 각 명령은 실행 상태를 변화시키는 자체 정의를 가지고 있음 
예시: ADD 명령은 스택에서 두 개의 값 합을 계산하여 스택에 넣고, 실행 비용(gas)을 감소시키며 프로그램 카운터를 1 증가시킴. 
이러한 실행 모델은 JIT 컴파일을 통해 최적화될 수 있으며, 기본적인 구현은 몇 백 줄의 코드로 이루어질 수 있음


## 블록체인과 채굴

![블록체인과 채굴](https://github.com/5juman/we/assets/120390638/ff75100a-31dc-4b04-a24d-516dbea92a7a)

이더리움 블록체인과 비트코인 블록체인은 유사하나, 차이점이 있음
이더리움과 비트코인에서의 각 블록체인 구조에 대한 주요 차이점: 
- 비트코인과 달리 이더리움은 트랜잭션 리스트와 가장 최근의 상태(state) 복사본을 가지고 있다는 것 
- 두개의 다른 값 - 블록 넘버와 difficulty - 이 또한 블록내에 저장됨

이더리움의 기본 블록 검증 알고리즘은 다음과 같음음:
1. 이전 블록이 존재하고 유효한지 확인
2. 현재 블록의 타임스탬프가 이전 블록보다 크며, 동시에 현재 시간에서 15분 후보다 이전인지 확인
3. 블록 넘버, 난이도, 트랜잭션 루트, 삼촌 루트, gas 리미트 등 여러 다양한 값들이 유효한지 확인
4. 블록에 포함된 작업 증명이 유효한지 확인
5. S[0]을 이전 블록의 마지막 상태로 가정
6. 각 트랜잭션에 대해 S[i+1] = APPLY(S[i], TX[i])를 계산, 소모된 총 gas가 GASLIMIT 초과 시 오류를 반환
7. 채굴자에게 지불된 보상을 S_FINAL에 추가
8. S_FINAL의 머클 트리 루트가 블록 헤더의 최종 상태 루트와 일치하는지 검증하여 블록의 유효성을 결정

이더리움의 효율적인 블록체인 관리는 상태를 트리 구조로 저장하여 각 블록에 모든 상태를 저장할 필요가 없게 함
→ 패트리샤 트리를 사용하여 노드를 효율적으로 수정하고 삽입 또는 삭제할 수 있게 하며, 인접한 블록 간에 대부분의 상태가 동일하여 데이터를 효율적으로 저장 가능 
이 방식은 비트코인에 비해 저장 공간을 5-20배 절약 가능함 
또한, 블록체인의 상태 전환 함수는 블록 검증 알고리즘의 일부로써 실행되며, 이는 모든 노드들이 트랜잭션에 의한 코드 실행을 동일하게 보장함
